# 세미조인
- 다른 테이블과 실제로 조인수행하지 않고, 다른테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리
  - 실제 리턴되는 레코드 결과는 outer 테이블의 행만 리턴한다. inner 테이블의 행은 리턴하지 않는다.(조인하지 않고 outer테이블은 inner테이블과 일치하는 레코드가 있는지 **체크**만 한다는게 이 의미이다.)

```sql
explain
select /*+ SET_VAR(optimizer_switch='semijoin=off') */ *
from employees e
where e.emp_no IN (select de.emp_no from dept_emp de where de.from_date = '1995-01-01');
```
![no_semijoin.png](images%2Fno_semijoin.png)
- 세미조인 최적화 없이 쿼리하면, 부모테이블 풀스캔(300233건) 하면서 서브쿼리의 조건에 일치하는지 비교 (too slow)
- in subquery는 부모테이블 풀스캔 -> 각 레코드들이 서브쿼리의 조건과 일치하는지 비교하기에 in subquery는 사용하지 않는것이 중요.
- 그러나 semi join 옵티마이저 최적화를 on시키면 내부적으로 최적화가 진행된다.

## 세미조인 최적화
1. Table Pull-Out
2. Duplicate Weed-out
3. First-Match
4. Loose Scan
5. Materialization

## Table Pull-out

```sql
explain
select *
from employees e
where e.emp_no in (select de.emp_no from dept_emp de where de.dept_no = 'd009');
```
- 해당 세미조인은 옵티마이저가 내부적으로 Table Pull-out 최적화를 진행한다.
- Table Pull-out 최적화를 진행하면, 세미조인의 서브쿼리를 아우터 테이블과의 조인으로 내부적으로 변경해서 쿼리를 실행한다.

![table-pull-out.png](images%2Ftable-pull-out.png)
- explain의 id가 모두 1로 동일하다. 이는 서브쿼리가 아닌 실제로 조인으로 바뀌어서 쿼리가 실행되었음을 알 수 있다.

### Table Pull-out 제한 사항
1. 세미조인의 서브쿼리에서만 사용 가능
2. 서브쿼리의 조인 키가 unique index나 pk여야 한다.
   - 위 세미조인의 서브쿼리는 `dept_emp`의 `emp_no`칼럼은 pk라서 Table pull out최적화가 가능
```sql
explain
select *
from employees e
where e.hire_date in (select de.from_date from dept_emp de where de.dept_no = 'd009');
```
   - 위 세미조인의 from_date칼럼은 dept_emp의 pk, unique index가 아니라서, Table pull out 최적화 일어나지 않음

### Table Pull-out 특성
1. Table Pull-out을 이용하더라도 추가적인 쿼리 최적화 가능하니, 최대한 사용하자.(무조건 사용하도록 하자)
2. 서브쿼리의 모든 부분을 Table Pull-out으로 조인으로 재작성하면 서브쿼리 자체가 모두 없어질수있음

> mysql 7에서 in subquery를 튜닝하려고 조인으로 바꾸어서 작성한 경험이 있는데, 의미없을수도 있었겠다. (물론 제한사항을 지키지 않았으면 의미있을수도 있음)
> 확실히 아는것과 모르는것엔 큰 차이가 있구나
> 

## firstmatch(퍼스트 매치)

- In subquery 형태의 세미조인을 `EXISTS(subquery)` 형태로 튜닝한 것과 비슷한 방법으로 실행되어 최저화된다.
- 실행계획의 id칼럼이 1로 조인으로 처리된다.
- **아우터 테이블에 대해 이너 쿼리(서브 쿼리)테이블에 일치하는 레코드 1건만 찾으면 더이상 이너 쿼리(서브 쿼리)테이블을 검색하지 않는 기법이다.**
```sql
explain
select *
from employees e
where e.first_name = 'Matt'
  and e.emp_no in (select t.emp_no from titles t where t.from_date BETWEEN '1995-01-01' and '1995-01-30');
```
- employees 테이블에서 `first_name = 'Matt'`인 데이터들을 찾고, 각 데이터(레코드)에 대해 서브쿼리부분의 테이블의 데이터들을 검색중(titles) `t.from_date BETWEEN '1995-01-01' and '1995-01-30'`인 조건에 맞는 데이터 찾으면 더이상 `titles`테이블 검색하지 않는다.

### firtmatch 제한조건
- group by나 집계함수가 사용된 서브쿼리의 최적화에는 사용할 수 없다.

### firstmatch 특성
- 서브쿼리에서 하나의 레코드만 검색도미ㅕㄴ 더이상 검색을 멈추기 때문에, (short-cut path로 실행됨) 서브쿼리를 참조하는 아우터 테이블이 먼저 조회된 이후에 서브쿼리의 테이블이 조회된다.
- 실행계획의 `extra`칼럼에 FirstMatch(테이블 이름)이 표시된다.
- '상관 서브쿼리'에서도 사용될 수 있다.
  - 서브 쿼리는 외부 테이블과 관계가 없이 단독적으로 실행되는 '단독 서브쿼리'와 외부 테이블과 관계가 있는 '상관 서브쿼리' 로 나눌 수 있다
  - 단독 서브쿼리: `select e.emp_no, e.first_name, (select count(*) from titles) as title_cnt from employees e;`
  - 상관 서브쿼리: `select * from employees e where e.emp_no in (select t.emp_no from titles t where t.from_date = e.hire_date);`

## LooseScan(루스 스캔)
```sql
select *
from departments d
where d.dept_no in (select de.dept_no from dept_emp de);
```
- departments 레코드수 9, dept_emp 테이블의 unique한 dept_no 개수 9개(group by한)
- dept_emp 테이블을 드라이빙 테이블로 하여, 루스 인덱스 스캔으로 유니크한 dept_no만 읽고 드리븐 테이블로 사용하는 departments검색한다.

- 세미조인을 조인으로 변환하여 실행
- 이너 서브쿼리를 드라이빙 테이블로 아우터 서브쿼리 테이블을 드리븐 테이블로

- 요약하면 **조인으로 처리하고 '루스 인덱스 스캔'방식으로 인덱스 검색해서 세미조인 최적화한다**

### LooseScan 특성
- 서브쿼리 테이블읽고(드라이빙 테이블) 그다음 아우터 테이블읽음(드리븐 테이블)
  - 조인으로 처리
- explain id모두 1(조인으로 처리했다는 의미)
- 루스 인덱스 스캔 사용할수 있는 조건이 있어야한다

## Materialization(구체화)
- 내부 임시 테이블을 생성해서 쿼리 최적화하는 방법
```sql
explain
select *
from employees e
where e.emp_no in (select de.emp_no from dept_emp de where de.from_date = '1995-01-01');
```
- employees테이블은 서브쿼리 이외에 아무 조건이 없어서 테이블 풀 스캔해야함.
- firtmatch전략을 이용해도 employees 테이블 풀스캔해야해서 별 도움이 안됨
- 서브쿼리 구체화(subquery Materialization)을 이용해서 최적화

![semioin_materialization.png](images%2Fsemioin_materialization.png)
1. subquery를 임시테이블로 만들고 (<<subquery 2>>), employees테이블과 조인한다음 결과 반환
2. 반환된 결과와 dept_emp테이블의 결과를 이용해 최종결과 반환

- 서브쿼리 임시테이블과 조인하여 조인 조건이 추가되닌까, 테이블 풀 스캔보다는 성능이 좋을것

### Materialization 제한사항
- 단독 서브쿼리에서만 동작한다

### Materialization 특징
- 서브쿼리에서 group by, 집계함수가 사용되어도 구체화 가능
- 내부 임시테이블이 사용된다.

## Duplicated Weed-out(중복제거)
- 세미조인을 조인으로 변경하고 중복된 레코드를 제거하는 방법으로 최적화

```sql
select *
from employees e
where e.emp_no in (select s.emp_no from salaries s where s.salary > 150000);
```
- emp_no는 중복이 있을 수 있다.
- 이때, 두 테이블을 조인하고, 중복을 제거한다: Duplicated Weed-out

![semioin_materialization.png](images%2Fsemioin_materialization.png)
- start temporary, End temporary가 Duplicated weed out으로 최적화되었다는 의미이다.

### Duplicated Weed-out 제한사항
- 서브쿼리에 groupby 집계함수가 사용되면 적용불가
- 상관 서브쿼리에서도 적용가능

### Duplicated Weed-out 특징
- 세미조인을 조인으로 처리하기 때문에 추가적인 방법으로 최적화 가능

## condition_fanout_filter(컨디션 팬아웃)
- 조인할때 (NL방식) 레코드수가 많은 테이블을 드라이빙 테이블로 이용해서 조인을 하면 드리븐 테이블로의 접근 수(메모리던 디스크던, 인덱스를 이용하던)가 늘어나 비효율적이다.
  - 옵티마이저가 내부적으로 조인하는 순서를 변경해준다.
- 조인할때 레코드 수에 따른 테이블 순서는 쿼리의 성능에 큰 영향을 미친다.

```sql
set optimizer_switch ='condition_fanout_filter=off';
    
explain
select *
from employees e
         join salaries s on s.emp_no = e.emp_no
where e.first_name = 'Matt'
  and e.hire_date BETWEEN '1985-11-21' and '1986-11-21';
```
- 컨디션 팬아웃 끄고 해당 쿼리 실행계획 확인하면
![condition_fan_out_off.png](images%2Fcondition_fan_out_off.png)
- employees테이블은 ix_firstname인덱스를 이용해 233 레코드를 검색했는데 그중 나머지 조건을 통해 필터링 해보니 100%모두 조건에 부합한다고 예측이 된 것이다.

```sql
set optimizer_switch ='condition_fanout_filter=on';
    
explain
select *
from employees e
         join salaries s on s.emp_no = e.emp_no
where e.first_name = 'Matt'
  and e.hire_date BETWEEN '1985-11-21' and '1986-11-21';
```
- 이번엔 컨디션 팬아웃 키고 해당쿼리 실행계획 확인하면
![condition_fan_out_on.png](images%2Fcondition_fan_out_on.png)
- ix_firstname인덱스로 233 레코드를 검색했는데 그중 26.07%만이 조건에 부합한다는 것으로 예측햇다.
  - 보다 정확하게 예측한 것이다.

- 즉 컨디션 팬아웃옵션을 이용하면 **실행 계획을 좀더 정확하게 예측하여 수립할수 있다.**
- 컨디션 팬아웃을 이용해, 실행계획 예측하는 방법으로는
  - 인덱스가 있을 때 -> 다른 인덱스(ix_hire_date)를 이용해 예측
  - 인덱스가 없을 떄 -> 현재 인덱스(ix_firtname)을 이용해 hire_date 칼럼값 분포도(히스토그램)로 예측
- 컨디션 팬아웃옵션은 옵티마이저가 정확한 예측을 위해, 실행되기에 그만큼 overhead가 있다.
  - 잘못된 실행계획 수립한적이 많이 없다면(고수라면) 해당 옵션을 사용하지 않는것이 오히려 쿼리 성능에 좋을 수 있다.
