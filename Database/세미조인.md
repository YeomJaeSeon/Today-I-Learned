# 세미조인
- 다른 테이블과 실제로 조인수행하지 않고, 다른테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리
  - 실제 리턴되는 레코드 결과는 outer 테이블의 행만 리턴한다. inner 테이블의 행은 리턴하지 않는다.(조인하지 않고 outer테이블은 inner테이블과 일치하는 레코드가 있는지 **체크**만 한다는게 이 의미이다.)

```sql
explain
select /*+ SET_VAR(optimizer_switch='semijoin=off') */ *
from employees e
where e.emp_no IN (select de.emp_no from dept_emp de where de.from_date = '1995-01-01');
```
![no_semijoin.png](images%2Fno_semijoin.png)
- 세미조인 최적화 없이 쿼리하면, 부모테이블 풀스캔(300233건) 하면서 서브쿼리의 조건에 일치하는지 비교 (too slow)
- in subquery는 부모테이블 풀스캔 -> 각 레코드들이 서브쿼리의 조건과 일치하는지 비교하기에 in subquery는 사용하지 않는것이 중요.
- 그러나 semi join 옵티마이저 최적화를 on시키면 내부적으로 최적화가 진행된다.

## 세미조인 최적화
1. Table Pull-Out
2. Duplicate Weed-out
3. First-Match
4. Loose Scan
5. Materialization

## Table Pull-out

```sql
explain
select *
from employees e
where e.emp_no in (select de.emp_no from dept_emp de where de.dept_no = 'd009');
```
- 해당 세미조인은 옵티마이저가 내부적으로 Table Pull-out 최적화를 진행한다.
- Table Pull-out 최적화를 진행하면, 세미조인의 서브쿼리를 아우터 테이블과의 조인으로 내부적으로 변경해서 쿼리를 실행한다.

![table-pull-out.png](images%2Ftable-pull-out.png)
- explain의 id가 모두 1로 동일하다. 이는 서브쿼리가 아닌 실제로 조인으로 바뀌어서 쿼리가 실행되었음을 알 수 있다.

### Table Pull-out 제한 사항
1. 세미조인의 서브쿼리에서만 사용 가능
2. 서브쿼리의 조인 키가 unique index나 pk여야 한다.
   - 위 세미조인의 서브쿼리는 `dept_emp`의 `emp_no`칼럼은 pk라서 Table pull out최적화가 가능
```sql
explain
select *
from employees e
where e.hire_date in (select de.from_date from dept_emp de where de.dept_no = 'd009');
```
   - 위 세미조인의 from_date칼럼은 dept_emp의 pk, unique index가 아니라서, Table pull out 최적화 일어나지 않음

### Table Pull-out 특성
1. Table Pull-out을 이용하더라도 추가적인 쿼리 최적화 가능하니, 최대한 사용하자.(무조건 사용하도록 하자)
2. 서브쿼리의 모든 부분을 Table Pull-out으로 조인으로 재작성하면 서브쿼리 자체가 모두 없어질수있음

> mysql 7에서 in subquery를 튜닝하려고 조인으로 바꾸어서 작성한 경험이 있는데, 의미없을수도 있었겠다. (물론 제한사항을 지키지 않았으면 의미있을수도 있음)
> 확실히 아는것과 모르는것엔 큰 차이가 있구나
> 

## firstmatch(퍼스트 매치)

- In subquery 형태의 세미조인을 `EXISTS(subquery)` 형태로 튜닝한 것과 비슷한 방법으로 실행되어 최저화된다.
- 실행계획의 id칼럼이 1로 조인으로 처리된다.
- **아우터 테이블에 대해 이너 쿼리(서브 쿼리)테이블에 일치하는 레코드 1건만 찾으면 더이상 이너 쿼리(서브 쿼리)테이블을 검색하지 않는 기법이다.**
```sql
explain
select *
from employees e
where e.first_name = 'Matt'
  and e.emp_no in (select t.emp_no from titles t where t.from_date BETWEEN '1995-01-01' and '1995-01-30');
```
- employees 테이블에서 `first_name = 'Matt'`인 데이터들을 찾고, 각 데이터(레코드)에 대해 서브쿼리부분의 테이블의 데이터들을 검색중(titles) `t.from_date BETWEEN '1995-01-01' and '1995-01-30'`인 조건에 맞는 데이터 찾으면 더이상 `titles`테이블 검색하지 않는다.

## firtmatch 제한조건
- group by나 집계함수가 사용된 서브쿼리의 최적화에는 사용할 수 없다.

## firstmatch 특성
- 서브쿼리에서 하나의 레코드만 검색도미ㅕㄴ 더이상 검색을 멈추기 때문에, (short-cut path로 실행됨) 서브쿼리를 참조하는 아우터 테이블이 먼저 조회된 이후에 서브쿼리의 테이블이 조회된다.
- 실행계획의 `extra`칼럼에 FirstMatch(테이블 이름)이 표시된다.
- '상관 서브쿼리'에서도 사용될 수 있다.
  - 서브 쿼리는 외부 테이블과 관계가 없이 단독적으로 실행되는 '단독 서브쿼리'와 외부 테이블과 관계가 있는 '상관 서브쿼리' 로 나눌 수 있다
  - 단독 서브쿼리: `select e.emp_no, e.first_name, (select count(*) from titles) as title_cnt from employees e;`
  - 상관 서브쿼리: `select * from employees e where e.emp_no in (select t.emp_no from titles t where t.from_date = e.hire_date);`