# 쿼리 힌트
- MySQL 서버 버전이 업그레이드 되면서 옵티마이저의 성능 또한 많이 높아짐
- 그러나 우리의 비즈니스 도메인을 MySQL이 100%이해하진 못한다.
  - 옵티마이저가 개발자나 DBA보다 실행계획을 잘 못 수립할 수 있다.
- 이럴 경우 **옵티마이저에게 쿼리의 실행 계획을 어떻게 수립할지 알려줄수있는 방법**이 필요하고 이런 목적으로 **힌트**가 제공된다.

## 쿼리 힌트 종류
1. 인덱스 힌트
2. 옵티마이저 힌트

- 인덱스 힌트는 각 DBMS(mysql, oracle, postgresql..)의 SQL 문법에 맞게 사용해야해서 `ANSI-SQL`을 준수하지 못하는 단점이 있다.
- 옵티마이저 힌트는 MySQL5.6 부터 힌트들을 '주석'으로 해석하기에 `ANSI-SQL` 표준을 준수한다고 볼 수 있다.
  - ANSI-SQL: DBMS들이 공통적으로 사용하는 SQL 표준 문법

> 가능하다면 인덱스 힌트보단 옵티마이저 힌트를 사용하자

# 인덱스 힌트

## STRAIGHT_JOIN
- 인덱스 힌트인 동시에 조인키워드이다.
- 여러개의 테이블이 조인되는 경우 **조인 순서를 고정**하는 역할을 한다.
- 여러개의 테이블을 조인하면 어떤 순서로 조인할지 알수없다.
  - 해당 상황에서 가장 최적화된 방법으로 옵티마이저가 선택하여 조인 순서를 결정하기에 알수 없다.(상황은 시시각각변함)

- 옵티마이저가 조인 순서 결정하는 기준
  1. 조인을 위한 조건에 인덱스 여부
  2. 조건에 맞는 레코드의 개수 (물론 조건에 맞는 레코드의 개수가 적은게 드라이빙 테이블 - io 줄수 있기에..)


```sql
explain
select  *
from employees e,
     dept_emp de,
     departments d
where e.emp_no = de.emp_no
  and d.dept_no = de.dept_no;
```
![no_straight_join.png](images%2Fno_straight_join.png)
- departments -> dept_emp -> employees 순서로 조인

```sql
-- use straight_join
explain
select straight_join  *
from employees e,
     dept_emp de,
     departments d
where e.emp_no = de.emp_no
  and d.dept_no = de.dept_no;

explain
select /*! straight_join */ *
from employees e,
     dept_emp de,
     departments d
where e.emp_no = de.emp_no
  and d.dept_no = de.dept_no;
```
![straight_join.png](images%2Fstraight_join.png)
- from절에 명시한 테이블 순서대로 조인이 이루어짐.

- 왠만하면 당시 상황의 통계정보를 통해 옵티마이저가 알아서 조인순서를 결정하지만 다음과 같은 경우엔 고려해볼만하다.
1. 임시테이블과 일반 테이블 조인
   - 일반 테이블의 조인 칼럼에 인덱스 없읕 때, 조건에 맞는 레코드 수가 적은 테이블을 드라이빙 테이블로 정하자.
2. 임시테이블끼리 조인
   - 임시테이블은 항상 인덱스 없으니, 크기가 작은 테이블 드라이빙 테이블로 정하자
3. 일반 테이블끼리 조인
   - 두 테이블 모두 인덱스 있거나 모두 인덱스 없으면 조건에 맞는 레코드 개수가 적은 테이블을 드라이빙 테이블로 정하자

> 조인할때, 조건에 맞는 레코드 수가 적은 테이블을 드라이빙 테이블로 정하는 이유는 I/O 횟수를 줄일 수 있기 때문이다.

### STRAIGHT_JOIN 힌트와 비슷한 힌드들
- JOIN_FIXED_ORDER: STRAIGHT_JOIN과 거의 동일 (모든 테이블의 조인순서 결정)
- JOIN_ORDER: 일부 테이블의 조인순서 결정
- JOIN_PREFIX: 일부 테이블의 조인순서 결정
- JOIN_SUFFIX: 일부 테이블의 조인순서 결정

## USE INDEX, FORCE INDEX, IGNORE INDEX
- 특정인덱스 강제로 사용하게하거나 강제로 사용하지 않게하는 인덱스 힌트
- 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러개 일 때, 옵타이마이저가 가끔 실수하는데 그 때 위의 강제로 특정 인덱스 사용하게 하는 힌트를 이용해 볼반하다.
  - 다시한번 말하지만 왠만하면 옵티마이저가 적절한 인덱스 사용하게 실행계획 수립한다.

### USE INDEX
- 인덱스 사용하도록 **권장**하는 인덱스 힌트. (항상 사용하는건 아님)

### FORCE INDEX
- USE INDEX보다 좀더 강하게 **권장**하는 인덱스 힌트 (요것도 항상 인덱스 사용하는건 아님)

### IGNORE INDEX
- 해당 인덱스 사용하지 못하게 하는 인덱스 힌트
- 테이블 풀스캔 유도할때 종종 사용함

```sql
explain select * from employees where emp_no = 10001;
explain select * from employees force index(`PRIMARY`) where emp_no = 10001;
explain select * from employees use index (`PRIMARY`) where emp_no = 10001;
```
![use_index_1.png](images%2Fuse_index_1.png)

- `emp_no`는 PK로 어차피 모두 PK를 이용해 검색한다.

```sql
explain select * from employees ignore index (`PRIMARY`) where emp_no = 10001;
explain select * from employees force index (ix_firstname) where emp_no = 10001;
```
![use_index_2.png](images%2Fuse_index_2.png)

- 둘다 테이블 풀스캔으로 검색했다.
  - `force`를 이용하더라도 무조건 특정 인덱스를 사용하지 않는다는게 재밌었다.

> 인덱스 힌트는 왠만하면 사용하지 않는게 좋다. 데이터 상황은 시시각각 변하므로, 옵티마이저가 해당 상황에 맞는 실행계획을 수립하도록 하는 것이 좋다. 옵티마이저 성능도 요즘엔 좋기 때문이다.

## SQL_CALC_FOUND_ROWS
- `LMIIT`을 이용하면 `LIMIT`에 지정한 레코드 수보다 조건에 맞는 레코드 수가 많아도 `LIMIT`에 지정한 수가 되면 검색을 **즉시** 멈춘다.
- 코런데.. `SQL_CALC_FOUND_ROWS`를 이용하면 `LIMIT`에 지정한 레코드 수가 되어도 검색을 멈추지 않는다... 왜!?!?!
- `SQL_CALC_FOUND_ROWS`를 이용하고, 바로 직후 `FOUND_ROWS()`함수를 이용하면 `LIMIT`이 있어도 해당 조건에 맞는 레코드 개수를 가져올 수 있다.
- 해당 함수의 용도를 느낄수도있는데, 바로 페이지네이션에서 전체 레코드가 몇 갠지 알고 싶을 떄, 사용될 수 있다. ㅎㅎ

> 실무 레거시에서 본적있는 함수인데.. ㅎㅎ

![no_use_sql_calc_found_rows.png](images%2Fno_use_sql_calc_found_rows.png)
- 해당 조건에 맞는 레코드 개수가 253개이다.

![sql_calc_found_rows.png](images%2Fsql_calc_found_rows.png)
- `found_rows()`결과를 보면 20이 아닌 253이다.
  - `SQL_CALC_FOUND_ROWS`를 이용하지 않았으면 20이 나온다.

### SQL_CAL_FOUND_ROWS 사용하지 마라
- `LIMIT 0, 20`을 이용해도 조건에 맞는 레코드 개수가 253개면 253번의 io가 일어난다.
  - 세컨더리 인덱스를 통해 인덱스 레인지 스캔이 이루어 났는데도 253번의 io가 일어남

```sql
select count(*) from employees where first_name = 'Georgi';
select * from employees where first_name - 'Georgi' limit 0, 20;
```

- `SQL_CAL_FOUND_ROWS` 이용하지 않으면 위 쿼리처럼 `count(*)` 집계함수를 이용할수 있는데 위 쿼리는 **커버링 인덱스**를 통해 실제 io가 필요없으므로 0번의 io가 일어난다.
- 즉, `SQL_CAL_FOUND_ROWS`는 느리고 성능에 좋지못한 io를 유발하므로 성능에 치명적이다.
  - cpu, memory와 같은 전기적 처리에 비해 기계적 처리인 디스크 작업이 훨씬 느린다. (둘간의 gap으로 병목현상을 막기위해 중간 기계장치들이 나온것처럼..)

- `SQL_CAL_FOUND_ROWS`는 개발자 편의에 의해 나온 함수이지 성능 향상을 위한 함수가 아니기에, 실무에서 어플리케이션 코드에 절대 사용하지말자.
  - 걍 사용하지마!

# 옵티마이저 힌트
- 옵티마이저 힌트는 매우 종류가 다양. 영향범위도 다양

## 옵티마이저 힌트 영향 범위
1. 인덱스
2. 테이블
3. 쿼리 블록
4. 글로벌(쿼리 전체)