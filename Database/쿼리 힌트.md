# 쿼리 힌트
- MySQL 서버 버전이 업그레이드 되면서 옵티마이저의 성능 또한 많이 높아짐
- 그러나 우리의 비즈니스 도메인을 MySQL이 100%이해하진 못한다.
  - 옵티마이저가 개발자나 DBA보다 실행계획을 잘 못 수립할 수 있다.
- 이럴 경우 **옵티마이저에게 쿼리의 실행 계획을 어떻게 수립할지 알려줄수있는 방법**이 필요하고 이런 목적으로 **힌트**가 제공된다.

## 쿼리 힌트 종류
1. 인덱스 힌트
2. 옵티마이저 힌트

- 인덱스 힌트는 각 DBMS(mysql, oracle, postgresql..)의 SQL 문법에 맞게 사용해야해서 `ANSI-SQL`을 준수하지 못하는 단점이 있다.
- 옵티마이저 힌트는 MySQL5.6 부터 힌트들을 '주석'으로 해석하기에 `ANSI-SQL` 표준을 준수한다고 볼 수 있다.
  - ANSI-SQL: DBMS들이 공통적으로 사용하는 SQL 표준 문법

> 가능하다면 인덱스 힌트보단 옵티마이저 힌트를 사용하자

# 인덱스 힌트

## STRAIGHT_JOIN
- 인덱스 힌트인 동시에 조인키워드이다.
- 여러개의 테이블이 조인되는 경우 **조인 순서를 고정**하는 역할을 한다.
- 여러개의 테이블을 조인하면 어떤 순서로 조인할지 알수없다.
  - 해당 상황에서 가장 최적화된 방법으로 옵티마이저가 선택하여 조인 순서를 결정하기에 알수 없다.(상황은 시시각각변함)

- 옵티마이저가 조인 순서 결정하는 기준
  1. 조인을 위한 조건에 인덱스 여부
  2. 조건에 맞는 레코드의 개수 (물론 조건에 맞는 레코드의 개수가 적은게 드라이빙 테이블 - io 줄수 있기에..)


```sql
explain
select  *
from employees e,
     dept_emp de,
     departments d
where e.emp_no = de.emp_no
  and d.dept_no = de.dept_no;
```
![no_straight_join.png](images%2Fno_straight_join.png)
- departments -> dept_emp -> employees 순서로 조인

```sql
-- use straight_join
explain
select straight_join  *
from employees e,
     dept_emp de,
     departments d
where e.emp_no = de.emp_no
  and d.dept_no = de.dept_no;

explain
select /*! straight_join */ *
from employees e,
     dept_emp de,
     departments d
where e.emp_no = de.emp_no
  and d.dept_no = de.dept_no;
```
![straight_join.png](images%2Fstraight_join.png)
- from절에 명시한 테이블 순서대로 조인이 이루어짐.

- 왠만하면 당시 상황의 통계정보를 통해 옵티마이저가 알아서 조인순서를 결정하지만 다음과 같은 경우엔 고려해볼만하다.
1. 임시테이블과 일반 테이블 조인
   - 일반 테이블의 조인 칼럼에 인덱스 없읕 때, 조건에 맞는 레코드 수가 적은 테이블을 드라이빙 테이블로 정하자.
2. 임시테이블끼리 조인
   - 임시테이블은 항상 인덱스 없으니, 크기가 작은 테이블 드라이빙 테이블로 정하자
3. 일반 테이블끼리 조인
   - 두 테이블 모두 인덱스 있거나 모두 인덱스 없으면 조건에 맞는 레코드 개수가 적은 테이블을 드라이빙 테이블로 정하자

> 조인할때, 조건에 맞는 레코드 수가 적은 테이블을 드라이빙 테이블로 정하는 이유는 I/O 횟수를 줄일 수 있기 때문이다.

### STRAIGHT_JOIN 힌트와 비슷한 힌드들
- JOIN_FIXED_ORDER: STRAIGHT_JOIN과 거의 동일 (모든 테이블의 조인순서 결정)
- JOIN_ORDER: 일부 테이블의 조인순서 결정
- JOIN_PREFIX: 일부 테이블의 조인순서 결정
- JOIN_SUFFIX: 일부 테이블의 조인순서 결정

## USE INDEX, FORCE INDEX, IGNORE INDEX
- 특정인덱스 강제로 사용하게하거나 강제로 사용하지 않게하는 인덱스 힌트
- 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러개 일 때, 옵타이마이저가 가끔 실수하는데 그 때 위의 강제로 특정 인덱스 사용하게 하는 힌트를 이용해 볼반하다.
  - 다시한번 말하지만 왠만하면 옵티마이저가 적절한 인덱스 사용하게 실행계획 수립한다.

### USE INDEX
- 인덱스 사용하도록 **권장**하는 인덱스 힌트. (항상 사용하는건 아님)

### FORCE INDEX
- USE INDEX보다 좀더 강하게 **권장**하는 인덱스 힌트 (요것도 항상 인덱스 사용하는건 아님)

### IGNORE INDEX
- 해당 인덱스 사용하지 못하게 하는 인덱스 힌트
- 테이블 풀스캔 유도할때 종종 사용함

```sql
explain select * from employees where emp_no = 10001;
explain select * from employees force index(`PRIMARY`) where emp_no = 10001;
explain select * from employees use index (`PRIMARY`) where emp_no = 10001;
```
![use_index_1.png](images%2Fuse_index_1.png)

- `emp_no`는 PK로 어차피 모두 PK를 이용해 검색한다.

```sql
explain select * from employees ignore index (`PRIMARY`) where emp_no = 10001;
explain select * from employees force index (ix_firstname) where emp_no = 10001;
```
![use_index_2.png](images%2Fuse_index_2.png)

- 둘다 테이블 풀스캔으로 검색했다.
  - `force`를 이용하더라도 무조건 특정 인덱스를 사용하지 않는다는게 재밌었다.

> 인덱스 힌트는 왠만하면 사용하지 않는게 좋다. 데이터 상황은 시시각각 변하므로, 옵티마이저가 해당 상황에 맞는 실행계획을 수립하도록 하는 것이 좋다. 옵티마이저 성능도 요즘엔 좋기 때문이다.

## SQL_CALC_FOUND_ROWS
- `LMIIT`을 이용하면 `LIMIT`에 지정한 레코드 수보다 조건에 맞는 레코드 수가 많아도 `LIMIT`에 지정한 수가 되면 검색을 **즉시** 멈춘다.
- 코런데.. `SQL_CALC_FOUND_ROWS`를 이용하면 `LIMIT`에 지정한 레코드 수가 되어도 검색을 멈추지 않는다... 왜!?!?!
- `SQL_CALC_FOUND_ROWS`를 이용하고, 바로 직후 `FOUND_ROWS()`함수를 이용하면 `LIMIT`이 있어도 해당 조건에 맞는 레코드 개수를 가져올 수 있다.
- 해당 함수의 용도를 느낄수도있는데, 바로 페이지네이션에서 전체 레코드가 몇 갠지 알고 싶을 떄, 사용될 수 있다. ㅎㅎ

> 실무 레거시에서 본적있는 함수인데.. ㅎㅎ

![no_use_sql_calc_found_rows.png](images%2Fno_use_sql_calc_found_rows.png)
- 해당 조건에 맞는 레코드 개수가 253개이다.

![sql_calc_found_rows.png](images%2Fsql_calc_found_rows.png)
- `found_rows()`결과를 보면 20이 아닌 253이다.
  - `SQL_CALC_FOUND_ROWS`를 이용하지 않았으면 20이 나온다.

### SQL_CAL_FOUND_ROWS 사용하지 마라
- `LIMIT 0, 20`을 이용해도 조건에 맞는 레코드 개수가 253개면 253번의 io가 일어난다.
  - 세컨더리 인덱스를 통해 인덱스 레인지 스캔이 이루어 났는데도 253번의 io가 일어남

```sql
select count(*) from employees where first_name = 'Georgi';
select * from employees where first_name - 'Georgi' limit 0, 20;
```

- `SQL_CAL_FOUND_ROWS` 이용하지 않으면 위 쿼리처럼 `count(*)` 집계함수를 이용할수 있는데 위 쿼리는 **커버링 인덱스**를 통해 실제 io가 필요없으므로 0번의 io가 일어난다.
- 즉, `SQL_CAL_FOUND_ROWS`는 느리고 성능에 좋지못한 io를 유발하므로 성능에 치명적이다.
  - cpu, memory와 같은 전기적 처리에 비해 기계적 처리인 디스크 작업이 훨씬 느린다. (둘간의 gap으로 병목현상을 막기위해 중간 기계장치들이 나온것처럼..)

- `SQL_CAL_FOUND_ROWS`는 개발자 편의에 의해 나온 함수이지 성능 향상을 위한 함수가 아니기에, 실무에서 어플리케이션 코드에 절대 사용하지말자.
  - 걍 사용하지마!

# 옵티마이저 힌트
- 옵티마이저 힌트는 매우 종류가 다양. 영향범위도 다양

## 옵티마이저 힌트 영향 범위
1. 인덱스
2. 테이블
3. 쿼리 블록
4. 글로벌(쿼리 전체)

## 쿼리 블럭 지정하여 옵티마이저 힌트 적용
- 하나의 SQL에 select는 여러번 사용될수 있고, select 키워드로 시작하는 서브쿼리 영역을 쿼리 블록이라고한다.
- 쿼리 블록에 영향을 미치는 옵티마이저 힌트는 해당 쿼리블록 내에서 사용될 수도 있지만, 외부 쿼리블록에서 사용될 수도있다.
  - 특정쿼리블록을 외부 쿼리블록에서 사용하려면 `QB_NAME()`힌트를 이용

```sql
explain
select /*+ JOIN_ORDER(e, s@subq1)*/
    count(*)
from employees e
where e.first_name = 'Matt'
  and e.emp_no in (select /*+ QB_NAME(subq1)*/ s.emp_no from salaries s where s.salary between 50000 and 50500);
```
![optimizer_hint_outer_query_block_apply.png](images%2Foptimizer_hint_outer_query_block_apply.png)
- QB_NAME()을 이용해 subq1이라는 쿼리블록에 이름을 주었고, JOIN_ORDER(조인 순서 결정)옵티마이저 힌트에서 subq1이라고 지정한 외부 쿼리블록에도 영향을 미치게 사용하였다.

## MAX_EXECUTION_TIME
- 옵티마이저 힌트중 **유일하게 실행계획에 영향을 미치지 않는 힌트**
- 단순히 **쿼리의 최대 실행 시간을 설정**
- ms 단위로 설정

```sql
select
    /*+ MAX_EXECUTION_TIME(100)*/
    *
from employees
order by last_name like 1;
```
![optimizer_hint_max_execution_time.png](images%2Foptimizer_hint_max_execution_time.png)

- 쿼리 실행시간이 100ms 넘어가서 실패한걸 볼 수 있다.

## SET_VAR
- MySQL 시스템 변수들도 실행계획에 영향을 미친다.
  - `join_buffer_size` 조인버퍼 크기 설정하는 시스템 변수같은 경우 해당 크기에 따라 조인버퍼를 활용할지 말지에 따라 실행계획이 정해진다.
- 특정 쿼리에 특정 시스템 변수를 적용하려 할 때, 필요한 옵티마이저 힌트이다.
- 다양한 형태의 시스템 변수 조정이 가능
- 모든 시스템 변수를 적용할순 없다.

```sql
explain
select /*+ SET_VAR(optimizer_switch='index_merge_intersection=off')*/
    *
from employees
where first_name = 'Georgi'
  and emp_no between 10000 and 20000;
```
- 두 인덱스 함께 사용한 뒤 결과의 교집합만 반환하는 'index_merge_intersection'을 off 한 뒤 실행계획을 수립하라는 옵티마이저 힌트를 적용한 것이다.
![set_var_index_merge_intersection_off.png](images%2Fset_var_index_merge_intersection_off.png)
- ix_firstname 인덱스 하나만 사용한 것을 확인할 수 있다.

- **해당 옵티마이저 힌트는 중요하여 기억하도록 하자**

## SEMIJOIN, NO_SEMIJOIN
- 세미조인 최적화엔 여러가지 방법이 있다. (Table pull-out, first match,...)
- SEMIJOIN 옵티마이저 힌트는 어떤 세미조인 최적화 전략을 사용할지 제어한다.
- NO_SEMIJOIN 옵티마이저 힌트는 세미조인 최적화 전략 사용하지 않게 제어한다.
  - Table Pull-out 최적화 전략은 무조건 더 나은 성능 향상을 보장하기에 별도 힌트 사용할수 없다. (in subquery -> join으로 바꾸어 처리하는 전략)

```sql
explain
select *
from departments d
where d.dept_no in (select de.dept_no from dept_emp de);
```
![semijoin_optimizer_hint_use_first_match.png](images%2Fsemijoin_optimizer_hint_use_first_match.png)
- first match 세미조인 최적화 전략을 이용한 예시이다.
- `SEMIJOIN`옵티마이저 힌트로 MATERIALIZATION 세미조인 최적화 전략을 사용하도록 해보자.

```sql
explain
select *
from departments d
where d.dept_no in (select
                        /*+ SEMIJOIN(MATERIALIZATION)*/
                        de.dept_no
                    from dept_emp de);
```
![optimizer_hint_semijoin_materialization.png](images%2Foptimizer_hint_semijoin_materialization.png)

- 세미조인 최적화 옵티마이저 힌트 (SEMIJOIN, NO_SEMIJOIN)은 서브쿼리에 작성한다.
  - 외부 쿼리 블록에 작성할수도있는데, 이때 서브쿼리의 쿼리블록의 이름을 `QB_NAME`으로 명시하면된다.

```sql
explain
select /*+ SEMIJOIN(@subq1 MATERIALIZATION)*/ *
from departments d
where d.dept_no in (select
                        /*+ QB_NAME(subq1)*/
                        de.dept_no
                    from dept_emp de);
```
- 서브쿼리의 쿼리블록의 이름을 `subq1`으로 지정한뒤 외부쿼리에서 세미조인 최적화 옵티마이저 힌트를 적용했다.

```sql
explain
select *
from departments d
where d.dept_no in
      (select /*+ NO_SEMIJOIN(DUPSWEEDOUT, FIRSTMATCH)*/
           de.dept_no
       from dept_emp de);

```
- NO_SEMIJOIN 옵티마이저 힌트로 DUPSWEEDOUT, FIRSTMATCH 세미조인 최적화전략 사용하지 않도록 제어한 예시이다.

## SUBQUERY
- 서브쿼리 최적화는 세미조인 최적화(Table Pull-out, firstmatch, ..)가 사용되지 못할 때 사용하는 최적화 방법으로 아래 두가지 형태로 최적화 가능

1. IN-to-EXISTS: 힌트 - `SUBQUERY(INTOEXISTS)`
2. Materialization: 힌트 - `SUBQUERY(MATERIALIZATION)`

- 안티 세미 조인 최적화에는 세미 조인 최적화가 사용될수 없어서 위의 두가지 최적화가 사용된다.

> 안티 세미조인: IN (SELECT ... FROM ...) 또는 EXISTS (SELECT ... FROM ...) 형태의 서브쿼리의 부정

## BNL, NO_BNL, HASHJOIN, NO_HASHJOIN
- Nested Loop join만 지원하는 MySQL의 경우 조인할 칼럼에 적당한 인덱스가 없으면 Driving table의 레코드 개수 만큼 driven table을 인덱스 풀스캔 or 테이블 풀스캔을 해야한다.
- 그래서 MySQL은 BNL(Block Nested Loop)를 통해 join buffer를 이용하여 성능 향상을 높이는 방법을 이용함. 
  - 물론 조인할 칼럼에 인덱스가 있는것이 더 중요하다.
- 그런데 BNL은 근본적인 해결책이 아니라 Hash Join보다 느림
- MySQL 8.0.19까진 BNL을 썻지만 8.0.20부턴 BNL을 Hash Join이 대체하도록 수정됨
  - 8.0.20부턴 BNL이 없다고 보면됨
- 그럼 위 옵티마이저 힌트는 어떻게 활용되냐면
  - 8.0.20 이전 버전엔 BNL, NO_BNL 유용했음
  - 8.0.20 이후부턴 BNL, NO_BNL의 대상이 Block nested Loop 조인 이 아닌, Hash join으로 적용됨
  - HASHJOIN, NO_HASHJOIN 옵티마이저 힌트는 8.0.18 에만 유효함.
    - 8.0.20이후에도 HASHJOIN, NO_HASHJOIN은 유효해야하지 않을까? BNL, NO_BNL 옵티마이저 힌트와 동일하게 사용되면 좋을거같은데..

```sql
explain
select /*+ BNL(e, de)*/ *
from employees e
         inner join dept_emp de on de.emp_no = e.emp_no;
```
- 본인 mysql 버전 8.0.33이므로 위 `BNL`옵티마이저 힌트로 인해 조인은 Hash join으로 처리됨
  - 인지 알았으나.. 네스티드 루프 조인으로 처리된다고함. 조인되는 조건의 칼럼의 인덱스가 적절히 준비되어 있으면 Hash join은 거의 사용되지 않는다.
  - 조인 칼럼의 인덱스를 모두 삭제해야 Hash join으로 처리됨

## JOIN_FIXED_ORDER, JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX
- 조인 순서 결정하기 위한 인덱스 힌트인 `straight_join`의 단점 두가지 때문에 사용함
1. FROM절의 테이블 순서를 조인할 순서와 맞춰야 한다는 번거러움
2. FROM절의 모든 테이블의 조인의 순서가 결정됨. 일부만 결정되고 나머진 옵티마이저에게 맡기는 방법이 없음.

- JOIN_FIXED_ORDER: STRAIGHT_JOIN과 동일하게 FROM절의 테이블 순서대로 조인 실행하게하는 옵티마이저 힌트
- JOIN_ORDER: FROM절의 테이블 순서가 아닌 힌트에 명시된 테이블의 순서대로 조인을 실행하게 하는 옵티마이저 힌트
- JOIN_PREFIX: 조인에서 드라이빙 테이블만 강제하는 옵티마이저 힌트
- JOIN_SUFFIX: 조인에서 드리븐 테이블(가장 마지막에 조인돼야 할 테이블들)만 강제하는 옵티마이저 힌트

```sql
explain
select * /*+ JOIN_FIXED_ORDER()*/
from employees e
         inner join dept_emp de on e.emp_no = de.emp_no
         inner join departments d on de.dept_no = d.dept_no;

explain
select * /*+ JOIN_ORDER(d, de)*/
from employees e
         inner join dept_emp de on e.emp_no = de.emp_no
         inner join departments d on de.dept_no = d.dept_no;

explain
select * /*+ JOIN_PREFIX(e, de)*/
from employees e
         inner join dept_emp de on e.emp_no = de.emp_no
         inner join departments d on de.dept_no = d.dept_no;

explain
select * /*+ JOIN_SUFFIX(de, e)*/
from employees e
         inner join dept_emp de on e.emp_no = de.emp_no
         inner join departments d on de.dept_no = d.dept_no;
```

## MERGE, NO_MERGE
- 예전 MySQL 버전에선 FROM절의 서브쿼리를 항상 **내부 임시 테이블**로 생성했다.
- 내부 임시 테이블을 **파생 테이블(Derived table)**이라고 한다.
- 내부 임시테이블을 이용하면 불필요한 자원 소모를 유발
- 그래서 외부 쿼리와 FROM 절의 서브쿼리를 병합하는 최적화를 도입함 (5.7, 8.0)
- 그래도 상황에 따라 외부 쿼리와 FROM절의 서브쿼리를 병합하는 것보다 내부 임시테이블을 이용하는게 더 효율적일수도있기에 그 때 사용하는 옵티마이저 힌트이다.

```sql
explain
select /*+ MERGE(sub)*/*
from (select * from employees where first_name = 'Matt') sub
limit 10;
```
- 외부쿼리와 sub 서브쿼리 병합하여 처리하는 것으로 실행계획 수립
![optimizer_hint_merge.png](images%2Foptimizer_hint_merge.png)

```sql
explain
select /*+ NO_MERGE(sub)*/*
from (select * from employees where first_name = 'Matt') sub
limit 10;
```
- FROM절의 서브쿼리를 내부 임시 테이블(파생테이블)을 이용하여 처리하는 것으로 실행계획 수립
![optimizer_hint_no_merge.png](images%2Foptimizer_hint_no_merge.png)

## INDEX_MERGE, NO_INDEX_MERGE
- 일반적으로 하나의 테이블당 하나의 인덱스를 사용해 쿼리를 처리하지만, 하나의 인덱스만으로 검색대상의 범위를 충분히 좁힐수 없다면 하나의 테이블에 여러개의 인덱스를 동시에 사용하는 **인덱스 머지**를 이용할 수도있다.
- 이 인덱스 머지를 제어할때 사용하는 옵티마이저 힌트이다.

```sql
explain
select *
from employees
where first_name = 'Georgi'
  and emp_no BETWEEN 10000 and 20000;
```
- employees하나의 테이블의 한 쿼리에 Primary key(emp_no), ix_first_name(first_name) 두 인덱스를 모두 이용한 뒤 교집한 레코드만 반환하는 인덱스 머지로 실행계획 수립함.
![optimizer_hint_no_use_index_merge.png](images%2Foptimizer_hint_no_use_index_merge.png)

```sql
explain
select /*+ NO_INDEX_MERGE(employees PRIMARY)*/*
from employees
where first_name = 'Georgi'
  and emp_no BETWEEN 10000 and 20000;
```
- `NO_INDEX_MERGE`옵티마이저 힌트를 이용해 PRIMARY 인덱스는 사용하지 않고 처리하도록 실행계획 수립함.
![optimizer_hint_use_no_index_merge.png](images%2Foptimizer_hint_use_no_index_merge.png)

## NO_ICP
- 들어가기전에 먼저 인덱스 컨디션 푸시다운 (page 324)다시 확인
  - 스토리지 엔진에서 인덱스를 이용해 레코드들 가져온 뒤, Mysql엔진에서 인덱스를 이용하지 못한 나머지 조건에 대해선 필터링 한다.
  - 인덱스 컨디션 푸시다운을 이용하면 최대한 스토리지 엔진에서 인덱스를 이용하지 못하는 필드에 대해서도 필터링 하여 mysql 엔진으로 전달한다.
  - mysql 5.5버전까진 인덱스를 사용하지 못하는 조건에 대해선 mysql엔진이 스토리지엔진으로 아애 전달해주지 않아서 icp(인덱스 컨디션 푸시다운)을 이용하지 못했는데 그 이후 버전부턴 icp이용가능.
- 즉 왠만하면 icp 사용하는게 이득이다.
- 그러나 icp 옵션을 키면 (옵티마이저 스위치) 실행계획 수립에 오히려 도움을 주지못할수도있다.
- 데이터는 시시각각 변하기에 해당 상황에 맞게 실행계획수립하는게 중요한데 icp옵션을 키면 옵티마이저가 실행계획 수립하는데 오히려 어렵게함.
  - icp 비활성화하면 조금더 유연하고 정확하게 실행계획을 옵티마이저가 수립할수있게함.
  - 근데 난 잘 모르곘다.. 이게 꼭 도움이 되는건가?

```sql
explain
select *
from employees
where last_name = 'Action'
  and first_name like '%sal';
```
- 인덱스 컨디션 푸시다운을 이용해, 최대한 스토리지엔진에서 이용하지못하는 first_name = '$sal' 조건도 필터링후 mysql엔진으로 전달한다.
![index_condition_push_down_no_icp.png](images%2Findex_condition_push_down_no_icp.png)
- `using index condition`이 icp 사용했다는 의미.

```sql
explain
select /*+ NO_ICP(employees ix_lastname_firstname)*/*
from employees
where last_name = 'Action'
  and first_name like '%sal';
```
- `NO_ICP`옵티마이저 힌트 이용하면 인덱스 컨디션 푸시다운 이용하지 않고 실행계획 수립함. 이렇게하면 시시각각 변하는 데이터 상황에 맞게 더 유연하게 옵티마이저가 실행계획 수립할수 있음!?

## SKIP_SCAN, NO_SKIP_SCAN
- page 237 인덱스 스킵스캔 확인
  - 인덱스 스킵스캔은 인덱스 활용할수 없는 조건에 대해서도 내부적으로 조건을 추가해 인덱스 사용할수있또록 만들어준다.
  - ix_gender_birthdate(gender, birthdate)
  - `explain SELECT gender, birth_date from employees where birth_date >= '1990-03-07';`
  - 원래는 인덱스 타지 않는 쿼리지만 내부적으로 탈수있또록 
    - `explain SELECT gender, birth_date from employees where gender = 'M' and birth_date >= '1990-03-07';`
    - `explain SELECT gender, birth_date from employees where gender = 'F' and birth_date >= '1990-03-07';`
    - 와 비슷한형태로 쿼리를 처리해 인덱스 사용하도록 바꾸어 처리함
- 훌륭한 최적화 기능이지만 누락된 선행 칼럼(gender와 같은)이 가지는 유니크한 값의 개수가 많아진다면 (카디널리티가 낮다면) 성능이 오히려 떨어진다.
- 그래서 인덱스 스킵 스캔 기능에 대해 제어할수있는 옵티마이저 힌트 `SKIP_SCAN`, `NO_SKIP_SCAN`이 있다.

```sql
explain
select /*+ NO_SKIP_SCAN(employees ix_gender_birthdate)*/ gender, birth_date
from employees
where birth_date >= '1965-02-01';
```
- 원래는 인덱스 스킵스캔을 사용하는 쿼리인데 사용하지 않고 실행계획 수립한 걸 볼 수 있다. (`using index from skip scan`이 없음)
![optimizer_hint_no_skip_scan.png](images%2Foptimizer_hint_no_skip_scan.png)

## INDEX, NO_INDEX
- 인덱스 힌트 대체하여 사용하는 옵티마이저 힌트
  - 왜? 옵티마이저 힌트는 주석을 이용해 ansi sql을 따르닌까. 표준화가 되어있어 DBMS가 바뀌어도 적용이 됨
- 인덱스 힌트는 특정 테이블 뒤에 사용했기에, 인덱스 이름만 나열하면 됐지만 옵티마이저 힌트로 사용하려면 테이블명과 인덱스 이름도 함께 명시하는것만 주의하자.

```sql
explain
select *
from employees use index (ix_firstname)
where first_name = 'Matt';

explain
select /*+ INDEX(employees ix_first_name)*/ *
from employees
where first_name = 'Matt';
```