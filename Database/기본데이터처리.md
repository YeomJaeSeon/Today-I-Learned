# 기본데이터 처리
- MySQL은 데이터 정렬, 그루핑등의 기본 데이터 가공 기능을 가지고 있음
- 어떤방식으로 MySQL이 위 기본적인 가공을 하는지 알아보자

## 풀테이블 스캔, 풀 인덱스 스캔
- 풀테이블 스캔: 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업 처리
- 풀인덱스 스캔: 인덱스의 데이터를 처음부터 끝까지 읽어서 요청된 작업 처리
  - 보통, 인덱스는 테이블의 2~3개의 칼럼을 이용해서 만들어지닌까, 테이블보다 크기가 작아 풀테이블 스캔보단 보편적으로 성능이 좋긴하다.

### 풀테이블 스캔 사용 경우
1. 레코드 건수가 너~~~~무 작아 인덱스 통해 읽는 것보다 풀테이블이 스캔이 더 빠른 경우(보통 테이블의 레코드들이 페이지 1개로 구성된 경우라고 한다.)
2. where, on절에 인덱스 사용할 조건이 없는 경우
3. 인덱스 레인지 스캔 사용할 수 있어도, 일치 레코드 건수가 테이블의 전체 레코드건수의 20~30%이상이 되는 경우
    - 이 땐, 풀테이블 스캔하고 필터링이 더 빠르다.

### 풀테이블 스캔 방법
- 풀테이블 스캔을 실행할때 한번의 몇개의 페이지를 읽어올지에 대한 시스템 변수 없다.
- 그렇다고 하나의 페이지씩만 읽어오는 건 아니다.(InnoDB 기준)
- 특정 테이블의 연속된 페이지가 읽히면(풀테이블 스캔) 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작됨
  - 리드어헤드: 어떤 영역의 데이터가 필요해질 거라고 예측해서 요청이 오기전 미리 디스크에서 읽어 InnoDB 버퍼풀에 가져다 두는것.
  - 포그라운드 쓰레드가 처음엔 하나의 페이지씩 읽다가 '특정 시점'부터는 읽기 작업을 백그라운드 스레드로 넘긴다. (4개 페이지 이상)
  - 그럼 포그라운드 스레드는 미리 버퍼풀에 준비된 데이터를 가져다 사용하기에 쿼리가 빠르다.

## 병렬 처리
- MySQL8.0부터 하나의 쿼리를 여러 쓰레드가 병렬적으로(동시에) 처리가 가능하다.
  - 여러 쿼리에 대해 여러 쓰레드가 병렬적으로 처리하는건 당연히 가능하다.(MySQL은 쓰레드기반임.)
- where 조건 없이 단순히 테이블 **전체 건수**를 가져오는 쿼리만 병렬로 처리 가능하다.

## ORDER BY 처리(Using filesort)
- 정렬 방법은 크게, **인덱스를 사용하는 방법**, 인덱스 사용하지 않고 **file sort를 이용하는 방법** 두가지로 나눌 수 있다.
- 인덱스 이용하는 방법은 이미 인덱스는 정렬되어있어 그대로 읽기만 하면되니 매우 빠르다.
  - 그러나 모든 경우를 인덱스만으로 정렬하는건 힘들다..
- file sort는 정렬해야할 레코드건수가 많지 않으면 **메모리**에서 filesort가 처리되니 충분히 빠르다.(sort buffer) 그러나 레코드 대상이 많아질수록 응답이 느려지는데 이유는 아래에서 확인해보자.
- `Explain`의 `Extra`에 Using filesort 메시지 여부로 인덱스 사용해서 정렬했는지, 인덱스 사용 하지 않고 정렬했는지 구분 가능

### 소트 버퍼 (sort buffer)
- MySQL은 정렬하기 위해, 별도의 메모리 공간 할당받아 정렬하는데 이를 **소트버퍼**라고 한다.
- 소트 버퍼는 정렬이 필요한 경우에만 할당됨
  - 쿼리 실행 완료되면 release
- `sort_buffer_size`라는 시스템 변수로 버퍼 크기 정할수 있다.

#### multi merge
- 소량의 레코드에 대해서 소트버퍼를 이용하면 빠르게 정렬가능하지만, 레코드 건수가 늘어나면 성능에 문제가 될 수 있다.
- 정렬해야할 레코드 건수가 소트버퍼의 크기보다 크면 **임시 저장을 위한 디스크**를 사용한다.

소트 버퍼 크기: 10kb
정렬해야할 레코드들 크기: 200kb

-> 위 경우는 정렬하려면 레코드들을 여러 조각으로 나누어서 처리해야함
1. 첫번째 조각 레코드들 10kb에서 정렬
2. 임시로 디스크에 기록
3. 두번째 레코드 조각 가져와 다시 정렬
4. 임시로 디스크에 기록
5. 끝날때 까지 반복

-> 버퍼 크기만큼의 정렬된 레코드를 임시 디스크와 병합해가며 정렬을 수행함.

이를 **멀티 머지** 라고 한다.

정렬해야할 레코드 건수가 많아지면 멀티머지 횟수도 많아지므로 성능에 좋지못하다.
- 소트버퍼 크기를 키우면 멀티머지 횟수는 줄어들겠지만, 무작정 키우는건 좋지 못하다. 메모리는 한정된 자원이고, 해당 한정된 자원을 주어진 상황에서 최적화해서 사용하기 위해선, 적절한 크기가 중요하다.
  - 스레드 풀, 프로세스 풀, 커넥션 풀도 개수가 무조건 많다고 좋은건 아닌것처럼. (아름다운 고원, plateau)

### 정렬 알고리즘
- 싱글패스: 레코드 전체를 소트 버퍼에 담아서 처리
- 투패스: 정렬 기준 칼럼만 소트 버퍼에 담아서 처리
  - 정렬 기준의 칼럼에 대해서만 소트 버퍼에 담아서 처리하고 그 이후 추가로 필요한 칼럼에 대해선 따로 조회한다.

- 특정 알고리즘이 좋은건 없고, 상황에 따라 어떤 알고리즘을 사용하냐를 정하는게 중요하다.
  - 레코드에 어어엄청 큰 칼럼의 타입(BLOB, TEXT)가 있으면, 투패스가 나을 것이다. 그렇지 않고 레코드의 크기가 작으면 싱글패스가 나을것

> 공식 명칙 아님 주의

### 정렬 처리 방법

#### 인덱스 이용한 정렬
- Extra에 별도 메시지 X
- 가장 성능이 좋음
- 조건: **ORDER BY 칼럼이 드라이빙 테이블에 속하고, ORDER BY 순서대로 인덱스 존재해야함, where절에 조건이 있다면 해당 조건과 order by 인덱스는 같아야함.**
- R-Tree, 전문검색 인덱스는 정렬에선 사용불가
- 실제 정렬이 되어있으니 그냥 읽으면 되니 빠르다.

#### 조인에서 드라이빙 테이블만 정렬
- Extra에 'using filesort'
- 성능 중간
- 조인 실행전에, **드라이빙 테이블의 레코드를 먼저 정렬한 다음** 조인을 실행
- 조건: **조인에서 첫번째로 읽히는 드라이빙 테이블의 칼럼만으로 order by 절 작성해야함**
#### 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
- Extra에 'using temporary, using filesort'
- 하나의 테이블만 정렬하는 경우는, 임시 테이블 필요X, 2개 이상의 테이블을 조인해서 그 결과 정렬해야할 때 임시 테이블 필요할수 있음
- 인덱스 사용 정렬, 드라이빙 테이블만 정렬하는 두 경우 사용하지 못하면 임시테이블 이용해서 저장 후 정렬한다.
- 성능 좋지 못하다. 조인하면 레코드의 크기도 커지고 건수도 많아지기에 가장 느린 방법이다 ㅠ
- 보통 드리븐 테이블의 칼럼으로 order by하려 하면 위 방법으로 정렬됨

### 정렬 처리 방법 성능 비교
쿼리 처리되는 방법 두가지
1. 스트리밍 방식
   - 최종적으로 필요한 데이터의 개수와 관계없이 조건에 일치되는 레코드가 있을 때마다 바로바로 데이터 전송해주는 방식
2. 버퍼링 방식
   - 필요한 데이터에 대한 모든 레코드가 처리된 후에 최종적으로 전송해주는 방식
   - 인덱스를 이용하지 않는 order by, group by는 모든 데이터에 대해 정렬, 그루핑을 해야하기에 스트리밍 방식이 불가하다.
     - 인덱스를 이용하는 order by는 limit으로 스트리밍이 가능하다.
     - 인덱스 이용하지 못하는 order by에 limit을 걸어도 mysql서버가 처리해야하는 작업량은 큰 변화가 없어서 큰 성능향상을 꾀할순 없다.

-> 보통 스트리밍 방식이 응답속도가 빠른데, 인덱스를 이용해서 정렬을 처리하는 방식만 스트리밍방식이 가능하기에, 나머지(드라이빙 테이블 정렬후 조인, 임시테이블에 조인된 결과 저장후 정렬)처리 방법은 버퍼링 방식으로밖에 처리가 되지 않아 'limit'쿼리를 이용하더라도 mysql 자체가 처리하는 작업량엔 큰 변화가 없어 성능이 느리다.

- "정렬 처리 방식은 성능에 큰 차이를 보인다. 인덱스만으로 정렬하는건 좋겠지만 불가능할 경우, 드라이빙 테이블을 정렬후 조인하는 차선책을 선택하도록 하자."

