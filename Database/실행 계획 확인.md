# 실행계획 확인

- `DESC`, `EXPLAIN` 으로 확인 가능
- mysql 8.0부턴, `explain`에 다양한 옵션 추가 가능
  - 출력 포멧, 실제 쿼리의 실행결과(실제로 쿼리를 날려보면서)까지 확인하는 기능

## 실행계획 출력 포멧
- 8.0버전 부터, JSON, TREE 형태의 출력포멧으로 실행계획을 볼수 있다.
- `FORMAT`이라는 옵션을 이용하여

### TREE 포멧

```sql
EXPLAIN FORMAT=TREE select *
from employees e
         inner join salaries s on e.emp_no = s.emp_no
where first_name = 'ABC';
```

- 결과
```text
-> Nested loop inner join  (cost=1.85 rows=9.39)
    -> Index lookup on e using ix_firstname (first_name='ABC')  (cost=0.35 rows=1)
    -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=1.5 rows=9.39)
```

### JSON 포멧
```sql
EXPLAIN FORMAT=JSON select *
    from employees e
    inner join salaries s on e.emp_no = s.emp_no
    where first_name = 'ABC';
```

- 결과
```text
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1.85"
    },
    "nested_loop": [
      {
        "table": {
          "table_name": "e",
          "access_type": "ref",
          ...
}
```

## 쿼리의 실행 시간 확인
- 8.0.18부터는 쿼리의 실행계획 뿐만 아니라, **단계별 소요된 시간 정보**도 확인할수 있는 **EXPLAIN ANALYZE**기능이 추가됨
- 항상 TREE 포멧으로 보여줌
  - `EXPLAIN ANALYZE`는 별다른 포멧 옵션을 사용할수 없이 TREE로만 보여줌

```sql
explain analyze
select e.hire_date, avg(s.salary)
from employees e
         inner join salaries s on e.emp_no = s.emp_no and s.salary >= 50000 and s.from_date <= '1990-01-01' and
                                  s.to_date > '1990-01-01'
where e.first_name = 'Matt'
group by e.hire_date;
```
- 결과
```text
-> Table scan on <temporary>  (actual time=18.3..18.3 rows=48 loops=1) (A)
    -> Aggregate using temporary table  (actual time=18.3..18.3 rows=48 loops=1) (B)
        -> Nested loop inner join  (cost=432 rows=121) (actual time=3.14..18.1 rows=48 loops=1) (C)
            -> Index lookup on e using ix_firstname (first_name='Matt')  (cost=81.5 rows=233) (actual time=3..9.91 rows=233 loops=1) (D)
            -> Filter: ((s.salary >= 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))  (cost=0.564 rows=0.521) (actual time=0.0341..0.0349 rows=0.206 loops=233) (E)
                -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=0.564 rows=9.39) (actual time=0.0325..0.0339 rows=9.53 loops=233) (F)

```

### EXPLAIN ANALYZE 읽는 법

1. 동일한 depth라면 위에서 부터
2. 들여쓰기 가장 많이 들어간 depth

-> D -> F -> E -> C -> B -> A

D: employees 테이블에서 ix_firstname인덱스로 조건에 일치하는 레코드들 조회
F: salaries 테이블에서 PRIMARY 인덱스를 이용해 위의 emp_no와 동일한 레코드들 조회
E: salary >= 50000, ... 다른 조건들로 필터링 해서
C: NLJ를 이용해 결과 조인후
B: 임시 테이블 이용해서 AGGREGATE하고 (group by 때문)
A: 임시테이블의 결과 읽어서 반환

- actual time: 실제 소요된 시간(평균적으로) (단위: ms)
- rows: 처리한 레코드 수
- loops: 반복 횟수

- employees 테이블에서 처리한 레코드 수가 '233'개이므로 salaries테이블의 loops수가 233임. (Nested Loop join)
- actual_time과 rows는 '평균'인데, 이유는 'loops' 반복의 개념이 있기 때문
- actual time=0.0325..0.0339는 첫 레코드 가져오는데 걸리는 시간이 '평균적으로' 0.0325ms, 마지막 레코드를 가져오는데 걸리는 시간이 '평균적으로' 0.0339이다.

- **EXPLAIN ANALYZE를 이용하면 싷행 계획뿐만 아니라 실제 쿼리를 실행!! 하고, 각 단계별 소요된 시간을 보여주는 것**
  - `EXPLAIN`보다 더 다양한 정보를 이용할수 있다.

# 실행계획 분석
- 실행계획 포멧보단, 실행계획를 통해서 알려주는 정보가 어떤 정보인지 이해하는 것이 중요하다.
- 포멧 지정없는 `EXPLAIN`의 경우 표형태로 1중이상의 결과가 표시됨
- **레코드 수: 쿼리에서 사용된 테이블(임시테이블까지 포함)의 개수**
- **실행 순서는 위에서 아래 순서대로 실행됨**
  - 위쪽, id값이 작을 수록 쿼리의 바깥부분이거나 먼저 접근한 테이블이고 아래쪽, id값이 클 수록 쿼리의 안쪽이거나 나중에 접근한 테이블이다.

## id 칼럼
- id칼럼은 단위 SELECT 쿼리 별로 부여되는 식별자 값

```sql
explain
select e.emp_no, e.first_name, s.from_date, s.salary
from employees e,
     salaries s
where e.emp_no = s.emp_no
limit 10;
```
![explain_select_id_2.png](images%2Fexplain_select_id_2.png)
- 조인으로 처리되면 조인되는 테이블의 개수만큼 레코드 개수가 존재함.
- 조인으로 처리되면 같은 id값이 부여됨

```sql
explain
select ((select count(*) from employees) + (select count(*) from departments)) as total_count;
```
![explain_select_id_1.png](images%2Fexplain_select_id_1.png)
- 조인으로 처리되지 않으면 다른 id값이 부여됨
  - 3개의 단위 select 쿼리로 구성되어 있으므로 explain id칼럼의 값이 모두 1 ~ 3으로 다른 것을 확인할 수 있다.

- 주의!
  - id칼럼이 테이블의 무조건 접근 순서를 의미하지 않는다. (위에서 id칼럼 작은게 먼저 접근한 테이블이라며?)

```sql
explain select *
from dept_emp de
where de.emp_no = (select e.emp_no from employees e where e.first_name = 'Georgi' AND e.last_name = 'Facello' limit 1);
```
![explain_id_seq_1.png](images%2Fexplain_id_seq_1.png)
- 테이블 접근순서 de -> e

그러나 analyze 때려보면
```sql
explain analyze select *
from dept_emp de
where de.emp_no = (select e.emp_no from employees e where e.first_name = 'Georgi' AND e.last_name = 'Facello' limit 1);
```

- 결과
```text
-> Filter: (de.emp_no = (select #2))  (cost=0.35 rows=1) (actual time=0.0825..0.0841 rows=1 loops=1)
    -> Index lookup on de using ix_empno_fromdate (emp_no=(select #2))  (cost=0.35 rows=1) (actual time=0.0813..0.0828 rows=1 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Limit: 1 row(s)  (cost=1.22 rows=1) (actual time=0.143..0.143 rows=1 loops=1)
            -> Covering index lookup on e using ix_lastname_firstname (last_name='Facello', first_name='Georgi')  (cost=1.22 rows=2) (actual time=0.131..0.131 rows=1 loops=1)
```
- 가장 들여쓰기가 많이된 부분부터 실행됨. (? 실행순서 내가 아는거랑 다름.. 이상.. 확인필요)

-> **`explain`의 id칼럼의 값은 순서를 나타내지만 무조건 맞는건아니다. explain analyze로 확인하면 더 정확한 정보 알수있다.**

## select_type 칼럼
- 단위 select 쿼리가 어떤 타입의 쿼리인지 표시하는 칼럼

### SIMPLE
- UNION, 서브쿼리 사용하지 않는 단순한 SELECT 쿼리의 경우 표현됨
- 쿼리가 아무리 복잡해도 select_type이 SIMPLE인 쿼리는 하나만 존재!? - 이해안됨. 아닌 쿼리들이 많은 확인필요
- 일반적으로 제일 바깥 SELECT 쿼리
```sql
explain select * from departments;
```
![explain_select_type_simple.png](images%2Fexplain_select_type_simple.png)

### PRIMARY
- UNION이나 서브쿼리를 가지는 SELECT쿼리의 실행계획에서 가장 바깥쪽에 있는 단위 쿼리는 select_type이 PRIMARY로 표시됨
- PRIMARY인 단위 쿼리는 하나만 존재
- 쿼리의 제일 바깥쪽에 있는 단위 select 쿼리가 PRIMARY로 표시됨

```sql
explain
select *
from employees where (select dept_no from departments d limit 1) = emp_no;
```
![explain_select_type_primary.png](images%2Fexplain_select_type_primary.png)

### UNION
- union으로 결합하는 단위 select 쿼리 가운데 첫번째를 제외한 두번째 이후 단위 select쿼리의 `select_type`은 UNION으로 표시됨 
- union의 첫번째 단위 select는 DERIVED(인시 테이블)로 표시됨
  - 쿼리 결과를 모아서 저장하는 임시 테이블

```sql
explain
select *
from ((select emp_no from employees e1 limit 10)
      union all
      (select emp_no from employees e2 limit 10)
      union all
      (select emp_no from employees e3 limit 10)) tb;
```
![explain_select_type_union.png](images%2Fexplain_select_type_union.png)
- 세개의 서브쿼리는 union all을 결합해 '임시 테이블'을 만들어서 사용하고 있으므로 union all의 첫번째 쿼리는 DERIVED이다.