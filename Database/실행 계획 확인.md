# 실행계획 확인

- `DESC`, `EXPLAIN` 으로 확인 가능
- mysql 8.0부턴, `explain`에 다양한 옵션 추가 가능
  - 출력 포멧, 실제 쿼리의 실행결과(실제로 쿼리를 날려보면서)까지 확인하는 기능

## 실행계획 출력 포멧
- 8.0버전 부터, JSON, TREE 형태의 출력포멧으로 실행계획을 볼수 있다.
- `FORMAT`이라는 옵션을 이용하여

### TREE 포멧

```sql
EXPLAIN FORMAT=TREE select *
from employees e
         inner join salaries s on e.emp_no = s.emp_no
where first_name = 'ABC';
```

- 결과
```text
-> Nested loop inner join  (cost=1.85 rows=9.39)
    -> Index lookup on e using ix_firstname (first_name='ABC')  (cost=0.35 rows=1)
    -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=1.5 rows=9.39)
```

### JSON 포멧
```sql
EXPLAIN FORMAT=JSON select *
    from employees e
    inner join salaries s on e.emp_no = s.emp_no
    where first_name = 'ABC';
```

- 결과
```text
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1.85"
    },
    "nested_loop": [
      {
        "table": {
          "table_name": "e",
          "access_type": "ref",
          ...
}
```

## 쿼리의 실행 시간 확인
- 8.0.18부터는 쿼리의 실행계획 뿐만 아니라, **단계별 소요된 시간 정보**도 확인할수 있는 **EXPLAIN ANALYZE**기능이 추가됨
- 항상 TREE 포멧으로 보여줌
  - `EXPLAIN ANALYZE`는 별다른 포멧 옵션을 사용할수 없이 TREE로만 보여줌

```sql
explain analyze
select e.hire_date, avg(s.salary)
from employees e
         inner join salaries s on e.emp_no = s.emp_no and s.salary >= 50000 and s.from_date <= '1990-01-01' and
                                  s.to_date > '1990-01-01'
where e.first_name = 'Matt'
group by e.hire_date;
```
- 결과
```text
-> Table scan on <temporary>  (actual time=18.3..18.3 rows=48 loops=1) (A)
    -> Aggregate using temporary table  (actual time=18.3..18.3 rows=48 loops=1) (B)
        -> Nested loop inner join  (cost=432 rows=121) (actual time=3.14..18.1 rows=48 loops=1) (C)
            -> Index lookup on e using ix_firstname (first_name='Matt')  (cost=81.5 rows=233) (actual time=3..9.91 rows=233 loops=1) (D)
            -> Filter: ((s.salary >= 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))  (cost=0.564 rows=0.521) (actual time=0.0341..0.0349 rows=0.206 loops=233) (E)
                -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=0.564 rows=9.39) (actual time=0.0325..0.0339 rows=9.53 loops=233) (F)

```

### EXPLAIN ANALYZE 읽는 법

1. 동일한 depth라면 위에서 부터
2. 들여쓰기 가장 많이 들어간 depth

-> D -> F -> E -> C -> B -> A

D: employees 테이블에서 ix_firstname인덱스로 조건에 일치하는 레코드들 조회
F: salaries 테이블에서 PRIMARY 인덱스를 이용해 위의 emp_no와 동일한 레코드들 조회
E: salary >= 50000, ... 다른 조건들로 필터링 해서
C: NLJ를 이용해 결과 조인후
B: 임시 테이블 이용해서 AGGREGATE하고 (group by 때문)
A: 임시테이블의 결과 읽어서 반환

- actual time: 실제 소요된 시간(평균적으로) (단위: ms)
- rows: 처리한 레코드 수
- loops: 반복 횟수

- employees 테이블에서 처리한 레코드 수가 '233'개이므로 salaries테이블의 loops수가 233임. (Nested Loop join)
- actual_time과 rows는 '평균'인데, 이유는 'loops' 반복의 개념이 있기 때문
- actual time=0.0325..0.0339는 첫 레코드 가져오는데 걸리는 시간이 '평균적으로' 0.0325ms, 마지막 레코드를 가져오는데 걸리는 시간이 '평균적으로' 0.0339이다.

- **EXPLAIN ANALYZE를 이용하면 싷행 계획뿐만 아니라 실제 쿼리를 실행!! 하고, 각 단계별 소요된 시간을 보여주는 것**
  - `EXPLAIN`보다 더 다양한 정보를 이용할수 있다.

# 실행계획 분석
- 실행계획 포멧보단, 실행계획를 통해서 알려주는 정보가 어떤 정보인지 이해하는 것이 중요하다.
- 포멧 지정없는 `EXPLAIN`의 경우 표형태로 1중이상의 결과가 표시됨
- **레코드 수: 쿼리에서 사용된 테이블(임시테이블까지 포함)의 개수**
- **실행 순서는 위에서 아래 순서대로 실행됨**
  - 위쪽, id값이 작을 수록 쿼리의 바깥부분이거나 먼저 접근한 테이블이고 아래쪽, id값이 클 수록 쿼리의 안쪽이거나 나중에 접근한 테이블이다.

## id 칼럼
- id칼럼은 단위 SELECT 쿼리 별로 부여되는 식별자 값

```sql
explain
select e.emp_no, e.first_name, s.from_date, s.salary
from employees e,
     salaries s
where e.emp_no = s.emp_no
limit 10;
```
![explain_select_id_2.png](images%2Fexplain_select_id_2.png)
- 조인으로 처리되면 조인되는 테이블의 개수만큼 레코드 개수가 존재함.
- 조인으로 처리되면 같은 id값이 부여됨

```sql
explain
select ((select count(*) from employees) + (select count(*) from departments)) as total_count;
```
![explain_select_id_1.png](images%2Fexplain_select_id_1.png)
- 조인으로 처리되지 않으면 다른 id값이 부여됨
  - 3개의 단위 select 쿼리로 구성되어 있으므로 explain id칼럼의 값이 모두 1 ~ 3으로 다른 것을 확인할 수 있다.

- 주의!
  - id칼럼이 테이블의 무조건 접근 순서를 의미하지 않는다. (위에서 id칼럼 작은게 먼저 접근한 테이블이라며?)

```sql
explain select *
from dept_emp de
where de.emp_no = (select e.emp_no from employees e where e.first_name = 'Georgi' AND e.last_name = 'Facello' limit 1);
```
![explain_id_seq_1.png](images%2Fexplain_id_seq_1.png)
- 테이블 접근순서 de -> e

그러나 analyze 때려보면
```sql
explain analyze select *
from dept_emp de
where de.emp_no = (select e.emp_no from employees e where e.first_name = 'Georgi' AND e.last_name = 'Facello' limit 1);
```

- 결과
```text
-> Filter: (de.emp_no = (select #2))  (cost=0.35 rows=1) (actual time=0.0825..0.0841 rows=1 loops=1)
    -> Index lookup on de using ix_empno_fromdate (emp_no=(select #2))  (cost=0.35 rows=1) (actual time=0.0813..0.0828 rows=1 loops=1)
    -> Select #2 (subquery in condition; run only once)
        -> Limit: 1 row(s)  (cost=1.22 rows=1) (actual time=0.143..0.143 rows=1 loops=1)
            -> Covering index lookup on e using ix_lastname_firstname (last_name='Facello', first_name='Georgi')  (cost=1.22 rows=2) (actual time=0.131..0.131 rows=1 loops=1)
```
- 가장 들여쓰기가 많이된 부분부터 실행됨. (? 실행순서 내가 아는거랑 다름.. 이상.. 확인필요)

- 확인내용
  - 2행 -> 5행 -> 4행 -> 3행 -> 1행 순으로 쿼리가 실행된다. 예제가 잘못되었다.

-> **`explain`의 id칼럼의 값은 순서를 나타내지만 무조건 맞는건아니다. explain analyze로 확인하면 더 정확한 정보 알수있다.**

## select_type 칼럼
- 단위 select 쿼리가 어떤 타입의 쿼리인지 표시하는 칼럼

### SIMPLE
- UNION, 서브쿼리 사용하지 않는 단순한 SELECT 쿼리의 경우 표현됨
- 쿼리가 아무리 복잡해도 select_type이 SIMPLE인 쿼리는 하나만 존재!? - 이해안됨. 아닌 쿼리들이 많은 확인필요
  - 확인결과: 조인으로 처리되었으면 id값이 같고, SIMPLE 행이 여러개 존재할수있음
- 일반적으로 제일 바깥 SELECT 쿼리
```sql
explain select * from departments;
```
![explain_select_type_simple.png](images%2Fexplain_select_type_simple.png)

### PRIMARY
- UNION이나 서브쿼리를 가지는 SELECT쿼리의 실행계획에서 가장 바깥쪽에 있는 단위 쿼리는 select_type이 PRIMARY로 표시됨
- PRIMARY인 단위 쿼리는 하나만 존재
- 쿼리의 제일 바깥쪽에 있는 단위 select 쿼리가 PRIMARY로 표시됨

```sql
explain
select *
from employees where (select dept_no from departments d limit 1) = emp_no;
```
![explain_select_type_primary.png](images%2Fexplain_select_type_primary.png)

### UNION
- union으로 결합하는 단위 select 쿼리 가운데 첫번째를 제외한 두번째 이후 단위 select쿼리의 `select_type`은 UNION으로 표시됨 
- union의 첫번째 단위 select는 DERIVED(인시 테이블)로 표시됨
  - 쿼리 결과를 모아서 저장하는 임시 테이블

```sql
explain
select *
from ((select emp_no from employees e1 limit 10)
      union all
      (select emp_no from employees e2 limit 10)
      union all
      (select emp_no from employees e3 limit 10)) tb;
```
![explain_select_type_union.png](images%2Fexplain_select_type_union.png)
- 세개의 서브쿼리는 union all을 결합해 '임시 테이블'을 만들어서 사용하고 있으므로 union all의 첫번째 쿼리는 DERIVED이다.

### DEPENDENT UNION
- DEPENDENT는 `UNION`, `UNION ALL`로 결합된 단위쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.

```sql
explain
select *
from employees e1
where e1.emp_no in (select e2.emp_no
                    from employees e2
                    where e2.first_name = 'Matt'
                    union
                    select e3.emp_no
                    from employees e3
                    where e3.last_name = 'Matt');
```
![select_type_dependent.png](images%2Fselect_type_dependent.png)

- `explain analyze`를 이용하면 e1테이블에 먼저 접근해 연산을 한 뒤, 서브 쿼리에 접근한다. 이때 e1 테이블의 칼럼 값이 서브쿼리에 영향읕 주기 때문에, 서브쿼리(내부쿼리)가 외부 의 값을 참조해서 처리되므로 select_type에 `DEPENDENT`키워드가 표시된다.

### UNION RESULT
- `UNION` 결과를 담아두는 테이블
- 8.0 이전엔 `UNION(UNION DISTINCT)`, `UNION ALL`의 결과를 임시테이블로 생성했지만 8.0 부턴 `UNION ALL`은 임시테이블을 사용하지 않도록 기능이 개선
  - `UNION(UNION DISTINCT)`은 여전히 8.0 에서 임시 테이블을 이용하여 결과를 버퍼.
    - 중복을 제거하려면 당연히 임시테이블에 합집합 결과 두고, 중복 제거하는 작업이 필요한거아닐까? `UNION(UNION DISTINCT)`는 임시 테이블이 무조건 필요할거라 생각됨.
- `UNION(UNION DISTINCT)`결과를 저장하는데 사용하는 임시테이블의 select_type이 `UNION RESULT`

> UNION vs UNION DISTINCT는 기능은 같지만 명시적으로 중복을 허용하지 않는다고 작성하는 것만 다름.

```sql
explain
select emp_no
from salaries
where salary > 100000
union
distinct
select emp_no
from dept_emp
where from_date > '2001-01-01';
```
![select_type_union_result_1.png](images%2Fselect_type_union_result_1.png)
- id 1, 2 단위쿼리의 결과를 union했다는 의미이다.
- 참고로 `UNION ALL`은 `UNUON RESULT`가 실행계획에 나오지 않는다. 8.0 이상의 버전 부턴, `UNION ALL`하는데 임시테이블 사용하지 않기 때문.

### SUBQUERY
- `FROM`절 이외에 사용되는 서브쿼리를 의미한다.

> FROM절에 사용되는 서브쿼리도 서브쿼리라고 부르지만, select_type에 SUBQUERY라고 표시되는건 FROM절 이외에 사용되는 서브쿼리이다. 
> FROM절에 사용되는 서브쿼리의 select_type은 DERIVED라고 표시된다.

```sql
explain
select e.first_name,
       (select count(*)
        from dept_emp de,
             dept_manager dm
        where dm.dept_no = de.dept_no) as cnt
from employees e
where e.emp_no = 10001;
```
![select_type_subquery.png](images%2Fselect_type_subquery.png)
- select절에 사용된 서브쿼리이므로 select_type에 SUBQUERY라고 표시됨

### DEPENDENT SUBQUERY
- 서브쿼리가 바깥쪽(outer) select쿼리에서 정의된 칼럼을 사용하는 경우 select_type에 `DEPENDENT SUBQUERY`로 표시됨

```sql
explain
select e.first_name,
       (select count(*)
        from dept_emp de,
             dept_manager dm
        where dm.dept_no = de.dept_no
          and de.emp_no = e.emp_no) as cnt
from employees e
where e.emp_no = 10001;
```
![select_type_dependent_subquery.png](images%2Fselect_type_dependent_subquery.png)
- 위 쿼리와의 차이는 서브쿼리 내에서 outer 쿼리의 칼럼을 사용 여부 차이밖에 없다.
- 안쪽의 서브쿼리 결과가 바깥쪽의 서브쿼리 결과에 의존적이므로 `DEPENDENT`라는 키워드가 select_type에 붙는다.
- DEPENDENT가 붙으면 외부쿼리가 먼저 수행된후 내부 쿼리가 실행되야 하므로 DEPNDENT키워드 없는 일반 서브쿼리보다 처리 속도가 **느리다**

### DERIVED
- **`DERIVED`는 단위 select쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.**
  - 임시 테이블을 파생 테이블 이라고도 부른다.
- 5.5버전 까지는 FROM절에 서브쿼리 사용되면 항상 `DERIVED`라고 표시되었는데(항상 임시테이블 만들었는데) 5.6버전 부터는 옵티마이저 옵션에 따라 서브쿼리를 외부쿼리와 통합하는 형태의 최적화등이 수행되기 때문에, FROM절에 서브쿼리 이용했다고 해서 `DERIVED`가 무조건 표시되진 않는다.
- 5.5버전 까지는 임시 테이블(파생 테이블)에 인덱스가 전혀 없으므로 다른 테이블과 임시테이블 조인할때 성능상 좋지 못하다. 그러나 5.6부터는 옵티마이저 옵션에 따라 임시 테이블에도 인덱스를 추가해서 만들수 있게 최적화 되었다.

```sql
explain
select *
from (select de.emp_no from dept_emp de group by de.emp_no) tb,
     employees e
where e.emp_no = tb.emp_no;
```
![select_type_derived.png](images%2Fselect_type_derived.png)

- mysql 버전업 하면서 조인 쿼리에 대한 최적화도 많이 좋아졌다.
  - 불필요한 서브쿼리는 조인으로 쿼리 재작성 등..
- 옵티마이저도 한계가 있으므로 **최적화된 쿼리를 작성하는 것이 중요하다.**

> TODO: 위 쿼리 같이 개선해볼까?

### DEPENDENT DERIVED
- from절의 서브쿼리가 외부 칼럼을 참조하기 위해선 `lateral join`을 이용해야한다.
- 래터럴 조인으로 사용된 테이블의 select_type에 `DEPENDENT DERIVED`가 표시된다.

```sql
explain select *
from employees e
         left join lateral ( select * from salaries s where s.emp_no = e.emp_no order by s.from_date desc limit 2) s2
                   on s2.emp_no = e.emp_no;
```
![select_type_dependent_derived.png](images%2Fselect_type_dependent_derived.png)
- `lateral`키워드 없애면 에러난다.

### UNCACHEABLE SUBQUERY
- 하나의 쿼리 문장에 서브쿼리가 하나만 있다해서 서브쿼리가 한번만 실행되는 건 아니다.
  - 여러번 사용될수있다.
- 이때, 매번 서브쿼리 결과를 조회하는 게 아닌, 캐시가 되어있다면 캐시된 데이터를 이용하면 된다.
  - 내부적인 캐시 공간에 넣어두고 캐시된 결과를 그대로 사용하게할수 있다.
  - 쿼리캐시(쿼리 자체 캐시해놓는 기능), 파생 테이블과는 무관한 기능 (그냥 서브쿼리 결과 데이터 캐시해놓는 기능이 있다 정도로 기억하자.)
- `SUBQUERY`, `DEPENDENT SUBQUERY`는 다른 방식으로 캐시가 되고 캐시된 데이터가 사용되는데.
  - `SUBQUERY`: 외부 데이터의 영향을 받지 않기 때문에, **처음 한번만 실행되어 그 결과를 캐시하고 필요할 때, 캐시된 결과를 이용한다**. (고정된 값 하나 캐시)
  - `DEPENDENT SUBQUERY`: 의존하는 외부의 칼럼 값에 의존하기 때문에, **바깥쪽 쿼리의 칼럼 값 단위로 캐시해두고 사용한다.** (의존하는 칼럼의 값 개수만큼 캐시)
- `UNCACHEABLE SUBQUERY`는 캐시를 사용할수 없을 때, 표시된다.
- 서브쿼리 캐시 불가능한 경우
  - 사용자 변수가 서브쿼리에 사용된 경우
  - NON-DETERMINISTIC속성의 스토어드 루틴이 서브쿼리내에 사용된경우
  - UUID(), RAND()와 같이 결과같이 호출될 때마다 달라지는 함수가 서브쿼리에 사용된 경우

```sql
explain
select *
from employees e
where e.emp_no = (select @status
                  from dept_emp de
                  where de.dept_no = 'd005');
```
![select_type_uncacheable_subquery.png](images%2Fselect_type_uncacheable_subquery.png)
- 사용자 변수 `@status`가 서브쿼리에서 사용되어, 캐시할수 없는 서브쿼리라고 표시되었다.

### UNCACHEABLE UNION
- UNCACHEBALE (캐시 불가능) + UNION (합집합)

### MATERIALIZED
- 5.6부터 도입된 select_type으로 FROM절이나 IN 서브쿼리 형태의 쿼리에 사용되는  서브쿼리의 최적화를 위해 사용된다. (세미조인 최적화기법중 하나)

```sql
explain
select *
from employees e
where e.emp_no in (select emp_no from salaries where salary between 100 and 1000);
```
![select_type_materialized.png](images%2Fselect_type_materialized.png)

- 서브쿼리 내용을 임시 테이블로 구체화(Materialization)한 후, 임시 테이블과 employees테이브릉ㄹ 조인하는 형태로 최적화되어 실행됨

## table 칼럼
- 실행계획의 표시는 **테이블 기준**으로 표시된다.
- table칼럼에는 사용된 테이블 이름이 표시된다. (alias 있으면 alias가 표시)

## ref 칼럼
- 접근방법 (type)이 `ref`(동등조건으로 여러개의 레코드 존재 가능)면, 참조 조건으로 어떤 값이 제공되었는지 보여준다.

1. const
```sql
# ref 상수값
explain
select *
from employees e
where emp_no = 10001;
```
![explain_ref_const.png](images%2Fexplain_ref_const.png)
- ref 참조 조건이 상수 (10001)이므로, `const`라고 표시됨.

2. 테이블명.칼럼명
```sql
# ref 다른테이블명.칼럼명
explain
select *
from employees e,
     dept_emp de
where e.emp_no = de.emp_no;
```
![explain_ref_table_column.png](images%2Fexplain_ref_table_column.png)
- de 테이블 기준으로, `e.emp_no`참조 조건으로 조회가 되기에, 조회되는 참조 조건 테이블명.칼럼명 이 노출됨
  - `test`는 스키마 이름임

3. func
```sql
# function
explain
select *
from employees e,
     dept_emp de
where e.emp_no = (de.emp_no - 1);
```
![explain_ref_func.png](images%2Fexplain_ref_func.png)
- ref 참조조건을 계산으로 값을 바꾸어 조인하기 떄문에, `func`로 표시됨
  - func 표시 조건
    1. 위 예시처럼 참조조건을 사용자가 임의로 계산으로 바꾸어 조회
    2. mysql 서버가 내부적으로 값을 변환 (다른 칼럼 타입을 참조 조건으로, ..)

## rows 칼럼
- 옵티마이저는 각 조건에 대해 여러 처리 방식을 나열하고 비용을 비교하여 최종적으로 하나의 실행 계획을 수립한다.
  - 각 처리 방식에 대해, 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정한다. (테이블의 레코드 수, 인덱스 값 분포도, 히스토그램..) 
- rows칼럼은 **실행계획의 효율성 판단을 위해 예측했던 레코드 건수**이다.
  - 통계정보를 참조해 옵티마이저가 해당 실행계획을 할 경우, 접근할 레코드 수를 예측한 것이기에, 정확하지 않다!!
  - rows칼럼에 표시되는 값은 반환하는 레코드 수의 예측치가 아니라 **쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지에 대한 예측치이다!!!** (반환하는 레코드가 10개여도 해당 10개를 가져오기 위해 1000개의 레코드에 접근한다면 rows칼럼엔 10이 아닌 1000이 표시된다.)

```sql
explain
select *
from dept_emp
where from_date >= '1985-01-01';
```
- 해당 조건은 `dept_emp`테이블의 거의 모든 레코드에 접근하기, `type`에 `ALL`로, 테이블 풀스캔로 처리하기로 옵티마이저가 실행계획을 수립한다. (`ix_fromdate`로 레인지 스캔하지 않고 테이블 풀스캔함.)
- `rows`칼럼에는 테이블 풀 스캔을 할 경우 접근해야할 레코드 수이기에 해당 테이블의 모든 레코드수가 노출된다.
![explain_rows_table_full_scan.png](images%2Fexplain_rows_table_full_scan.png)


```sql
explain
select *
from dept_emp
where from_date >= '2002-07-01';
```
- 해당 조건은 옵티마이저가 `ix_fromdate`로 레인지 스캔하는 것으로 실행계획 선택
- **2002-07-01 보다 크거나 같은 레코드가 292건이 존재할것으로 옵티마이저는 예측하였기에 rows칼럼엔 292가 표시된다.**
  - 다시한번 !! 실행계획은 테이블 정보, 인덱스 정보, 히스토그램등 다양한 통계정보로 예측하는 것이기에 실제로 접근하는 레코드 수와는 다르게 표시될수있다.
![explain_rows_range_scan.png](images%2Fexplain_rows_range_scan.png)
