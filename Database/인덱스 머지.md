# 인덱스 머지
- 대부분의 경우, 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행계획을 수립
  - where절이 여러개여도, 하나의 인덱스만 사용하고 나머지 조건은 체크(필터링)하는 것이 일반적
- 그러나 하나의 인덱스를 통해 필터링을 해도 너무 많은 레코드가 체크(필터링)조건으로 남아있다면 2개이상의 인덱스를 이용해 실행계획을 수립할수있다.

## 인덱스 머지 3가지 실행계획
- 여러개의 인덱스를 하나의 테이블에 이용하는 것은 동일하지만, 어떤 방식으로 이용할지에 대한 방법은 모두 다르다.

### index_merge_intersection
- 여러개의 인덱스를 이용해 각각 검색하고, 그 결과의 **교집합**만 반환

```sql
explain
select *
from employee_name
where first_name = 'Georgi'
  and emp_no between 10000 and 20000;
```
![index_merge_intersection.png](images%2Findex_merge_intersection.png)

- ix_first_name(first_name), primary(emp_no) 두 인덱스를 각각 이용후 교집합만 반환
- 물론, 둘중 하나의 인덱스만 이용했는데 하나의 인덱스로 적은 레코드 수가 검색되면 하나의 인덱스만 사용하고 나머지는 필터링 했을 것이다, 그게 아니라 두 인덱스를 사용한것이다.
  - 두 조건 모두 많은 레코드 수를 가져와야해서 인덱스 머지를 이용한 것.

```sql
select count(*)
from employee_name
where first_name = 'Georgi';
```
- 253

```sql
select count(*)
from employee_name
where emp_no between 10000 and 20000;
```
- 10000

```sql
select count(*)
from employee_name
where first_name = 'Georgi'
  and emp_no between 10000 and 20000;
```
- 14

- 인덱스 머지를 이용하지 않았다면, ix_firstname인덱스만 이용했다면 253번의 io중 14개만 의미있을것이고 primary 인덱스만 이용했다면 10000 io중 14개만 의미있을 것이여서 매우 비효율적이였을 것이다.

- 인덱스 확장에서 배운것처럼 세컨더리 인덱스는 프라이머리 키를 포함하고 있기 때문에 index_merge사용하지 않는 것이 더 성능에 좋을수도있다.(ix_firstname 인덱스만 이용하는 것)
```sql
explain select /*+ SET_VAR(optimizer_switch='index_merge_intersection=off') */ *
from employee_name
where first_name = 'Georgi'
  and emp_no between 10000 and 20000;
```
- 해당 쿼리만 `index_merge_intersection off` 시킴

### index_merge_union
- where절에 사용된 2개이상의 조건이 각각의 인덱스를 사용하되 **OR** 연산자로 연결된 경우 사용될수있는 인덱스 머지 방법
- 쿼리의 결과들을 합집합으로 연산하여 반환

```sql
explain
select *
from employees
where first_name = 'Matt'
   OR hire_date = '1987-03-31';
```
![index_merge_union.png](images%2Findex_merge_union.png)

- 각 where절의 결과를 합집합하면 `first_name='Matt'`, `hire_date='1987-03-31'` 두 조건에 모두 포함되는 레코드가 중복될 것이다.
  - 결과 레코드가 중복되면 안됨.
- 합집합 하기전 각 레코드들은 이미 pk로 정렬되어 있으므로 우선순위 큐 자료구조를 이용해, 두 집합에서 데이터를 하나씩 가져와 비교하면서 중복되지 않게 거른다.
  - pk기준으로 이미 정렬이 되어있으므로 별도의 정렬작업 하지 않음
  - pk로 이미 정렬되어있다는 말은 innodb storage engine의 클러스터링 인덱스의 특성이지!?(TODO: 의견나누기, 왜 why?)

```text
- chat gpt 의견입니다.

MySQL의 InnoDB 스토리지 엔진에서 보조 인덱스는 인덱싱된 열의 복사본과 기본 키 값을 포함하는 B-트리 데이터 구조로 구현됩니다. 기본 키 값은 테이블의 기본 키인 클러스터형 인덱스의 해당 행에 대한 포인터로 사용됩니다.

보조 인덱스를 사용하는 쿼리를 실행하면 InnoDB는 인덱스를 읽어 일치하는 행을 찾은 다음 보조 인덱스에 저장된 기본 키 값을 사용하여 클러스터형 인덱스에서 해당 행을 검색합니다. 클러스터형 인덱스의 행은 기본 키에 따라 정렬되므로 클러스터형 인덱스에서 검색된 행은 기본 키 순서로 반환됩니다.

따라서 보조 인덱스를 사용하여 테이블을 쿼리하면 쿼리에서 반환된 행이 기본 키 값을 기준으로 정렬됩니다. 이 동작은 "인덱스 순서 스캔"으로 알려져 있으며 쿼리 성능을 향상시키기 위해 InnoDB 스토리지 엔진에서 사용하는 일반적인 최적화입니다.

기본 키 값의 정렬 순서는 기본 키의 데이터 유형 및 데이터 정렬에 따라 다릅니다. 보조 인덱스를 사용하여 쿼리에서 반환된 결과의 정렬 순서를 변경하려는 경우 쿼리에 `ORDER BY` 절을 추가할 수 있습니다.
```

### index_merge_sort_union
- union(합집합)연산중 중복을 제거하기 위해 정렬이 필요한데, 별도의 정렬이 필요한 경우 사용되는 인덱스 머지방법
  - pk기준으로 이미 정렬되어있으니 대부분의 경우는 필요없음

```sql
explain
select *
from employees
where first_name = 'Matt'
   OR hire_date between '1987-03-01' and '1987-03-31';
```
![index_merge_sort_union.png](images%2Findex_merge_sort_union.png)
- `Between` 조건의 레코드 결과는 pk기반으로 정렬이 되어있지 않아서, 별도의 정렬을 통해 중복을 제거해야해서 'sort_union'방법으로 인덱스를 머지한다.

> Between은 해당 칼럼을 기준으로 정렬된 레코드가 반환되네. (TODO: 의견나누기)