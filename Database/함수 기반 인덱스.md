# 함수 기반 인덱스
- 일반적인 인덱스는 칼럼 값 일부(앞부분), 전체에 대해서만 인덱스 사용가능
  - 인덱스의 칼럼값 변형하면 사용할수없다.(함수적용)(B-Tree에 저장된 값과 다르니 당연히 사용할 수 없다.)

- 함수기반 인덱스 mysql에서 사용하는 2가지 방법
1. 가상칼럼 이용
2. 함수를 이용 (???)

## 가상칼럼을 이용한 인덱스
```sql
create table user_test(
    user_id BIGINT,
    first_name varchar(10),
    last_name varchar(10),
    PRIMARY KEY (user_id)
);

alter table user_test
    add full_name varchar(30) as (concat(first_name, ' ', last_name)) virtual,
    add index idx_fullname (full_name);
```
- select하거나 desc해보면 실제로 full_name이라는 칼럼이 생성이 된걸 확인할수 있다.
- 즉, **가상칼럼도 새로운 칼럼을 추가하는것과 같아서, 테이블의 구조가 변경된다.**
- 해당 가상칼럼으로된 인덱스를 이용해 조회하면 당연히 인덱스 사용이 가능하다.
```sql
-- 1
explain select * from user_test where full_name = 'yeom jaeseon';
-- 2
explain select * from user_test where concat(first_name, ' ', last_name) = 'yeom jaeseon';
```
- 실행계획 돌려보니, 1은 당연히 인덱스 타야될테고(실제로 탄다.), 2도 탄다.
- 2는 왜 인덱스 타지?
  - 만개의 데이터 넣고 확인해봐도 동일하다. 가상칼럼을 이용해서 인덱스를 만들면 **함수를 이용한 조회에서도** 인덱스가 탄다... 신기하네

## 함수를 이용한 인덱스
- 가상칼럼을 이용해서 함수를 통해 인덱스 태우는 방법은 칼럼을 추가하는 것과 동일하여 테이블 구조를 변경시키는 단점이있다.
- 함수 인덱스를 이용하면 **테이블 구조 바뀌지 않는다.**
- 다만 해당 함수를 이용해야만 함수 인덱스를 탄다.

```sql
create table user_test2(
    user_id BIGINT,
    first_name varchar(10),
    last_name varchar(10),
    PRIMARY KEY (user_id),
    index idx_fullname ((concat(first_name, ' ', last_name)))
);
```
- 인덱스에 `concat`함수 인덱스를 생성했다.

```sql
-- 1
explain select * from user_test2 where concat(first_name, ' ', last_name) = 'yeom jaeseon';
-- 2
explain select * from user_test2 where replace(replace(concat(first_name, ' ', last_name), 'y', 'Y'), 'Y', 'y') = 'yeom jaeseon';
```
- 1만개 데이터 넣고 테스트해보니 1번은 인덱스 탄다.
  - 함수인덱스와 동일한 함수를 이용해야 탄다.
- 2번은 인덱스 타지않는다.
  - 결과 데이터는 동일하나 함수가 다르면 함수인덱스 타지 않는다.

# 소감
- 함수를 이용해 검색하는 쿼리도 인덱스를 태울수있다는게 신선했음
- 일반적인 상황에선 함수인덱스를 이용하는 상황이 존재할까? 뭔가 테이블 구조를 바꾸기 어렵고, 엄청 많은 레코드가 들어있고, 조회가 너무 느릴때 사용할만하나? 쿼리를 튜닝해서 개선하는 방법도 도저히 안되면 사용할만한듯하다.